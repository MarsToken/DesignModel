package com.example.designmodel.pattern;

/**
 * * 创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。
 * * 结构型模式：把类或对象结合在一起形成一个更大的结构。
 * * 行为型模式：类和对象如何交互，及划分责任和算法。
 * 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、构建者模式、原型模式。
 * 原型模式：Intent clone接口的实现
 * 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
 * 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
 * 二十三种设计模式
 * 一单两厂原构建，
 * 外代组亨装适桥。
 * 策略模板两状态，
 * 观迭任命中解者。
 * 行为关系模式：
 * 第一类：父类与子类：策略模式，模板方法模式
 * 第二类：两个类之间：观察者模式，迭代子模式，责任链模式，命令模式
 * 第三类：类的状态：备忘录模式，状态模式
 * 第四类：通过中间类：访问者模式，中介模式，解释器模式
 * <p>
 * 其实还有两类：并发型模式和线程池模式。简单工厂模式不是设计模式
 * <p>
 * 三种工厂模式的对比，简单工厂模式有（单个方法，多个方法，静态方法，一般用静态方法的）工厂没有抽象接口，每次加工厂都得改工厂类，不符合开闭原则
 * 工厂方法模式：有工厂抽象接口，适合单一需求，比如苹果工厂生产苹果，香蕉生产香蕉
 * 抽象工厂模式：适合产品簇需求，比如联华工厂生产红富士苹果和芝麻蕉
 * 专卖店和百货商场的区别！
 * <p>
 * 装饰者模式和代理模式的区别：微妙的细节，巨大的反差！！！
 * 使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，
 * 而装饰者能够在运行时递归地被构造
 * 主要体现在：代理或装饰者的构造函数里：代理模式代理的对象不对外暴露，装饰者装饰的对象必须对外暴露
 * 第一段说的是代理模式，侧重于不能直接访问一个对象，只能通过代理来间接访问，比如对象在另外一台机器上，或者对象被持久化了，
 * 对象是受保护的。对象在另外一台机器上，其实就是rpc，感兴趣的可以看看dubbo的源码本地反问的其实就是远程对象的代理，
 * 只不过代理帮你做了访问这个对象之前和之后的很多事情，但是对使用者是透明的了。对象被持久化了，比如mybatis的mapperProxy。
 * 通过mapper文件自动生成代理类。第三种，对内核对象的访问。
 * 第二段说的是装饰器模式是因为没法在编译器就确定一个对象的功能，需要运行时动态的给对象添加职责，
 * 所以只能把对象的功能拆成一一个个的小部分，动态组装，感兴趣的可以看看dubbo的源码，里面的mock，cluster，failover
 * 都是通过装饰器来实现的。因为这些功能是由使用者动态配置的。但是代理模式在编译器其实就已经确定了和代理对象的关系。
 * 第三段说的是，这个两个设计模式是为了解决不同的问题而抽象总结出来的。是可以混用的。可以在代理的基础上在加一个装饰，
 * 也可以在装饰器的基础上在加一个代理。感兴趣的去看看dubbo源码，里面就是这么实现的。
 * <p>
 * 观察者模式：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生改变时，会通知所有观察者对象，使他们能够自动更新自己。
 * 命令模式：
 * 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
 * 作用：
 * 1、它能较容易地设计一个命令队列；
 * 2、在需要的情况下，可以较容易地将命令记入日志；
 * 3、允许接收请求的一方决定是否要否决请求；
 * 4、可以容易地实现对请求的撤销和重做；
 * 5、由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。
 * 区别：
 * 命令模式发起通知方内部只有命令的对象，通过命令来完成。--通知的是命令。
 * 观察者模式发起通知的内部是接收通知的对象，通过调用接受对象的方法来完成。--通知的是接收对象，由接收对象自己执行对应的方法。
 * <p>
 * Created by hp on 2020/3/10.
 *
 * 1.单一职责：
 * 单一职责原则规定一个类应该只有一个引起它变化的原因，换句话说，一个类或者模块应该有且只有一个改变的原因（即职责）。
 * 这里的“职责”是指类变化的原因，如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责，违反了单一职责原则
 * 可以参考委托模式，但是粒度不能那么小！！！
 * 比如：1.功能性 假设你正在开发一个用户管理模块，该模块最初包含了用户注册、登录、信息修改和删除等多个功能。
 * 将UserManager类拆分为多个小类，如UserRegistration（负责用户注册）、UserLogin（负责用户登录）、
 * UserProfileUpdate（负责用户信息修改）和UserDeletion（负责用户删除）。
 * 每个小类都只负责一项职责，代码更加清晰和易于维护。
 * 2.依赖倒置：
 * 高层不应该依赖底层，两者都应该依赖抽象，即面向接口编程
 * 比如：让购物车类（ShoppingCart）直接依赖于具体的支付方式类（如PayPalPayment）不合理，应该依赖一个支付接口（Payment）
 * 3.接口隔离（接口粒度要恰当大）：
 * 客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。换句话说，接口的设计应该尽量细化，
 * 每个接口只包含客户端需要的方法，而不是将所有可能的方法都放在一个接口中
 * 比如：如果设计一个统一的Printer接口，包含print、scan和copy三个方法，那么对于只支持打印功能的打印机来说，
 * 实现这个接口会显得冗余，因为scan和copy方法对它来说是多余的
 * 不同类型的打印机实现相应的接口。例如，喷墨打印机和激光打印机只实现Printable接口，而多功能一体机则实现Printable、
 * Scannable和Copyable三个接口
 * 4.迪米特法则：（往往添加个中介者类）
 *也被称为最少知识原则（Least Knowledge Principle，LKP），该原则的核心思想是强调一个对象应该对其他对象有最少的了解，
 * 只与直接相关的对象（即“朋友”）进行通信，而不与陌生的对象进行交互。
 * 举例：
 * 在一个游戏开发中，游戏启动时需要初始化多个组件，如UI、人物和声音等。
 * 如果将这些初始化代码直接写在MainGame类中，会导致MainGame类对其他组件有过多的了解。
 * GameAbout类中定义UIprepare、Personprepare和Musicprepare等方法来分别初始化UI、人物和声音等组件。
 * 这样MainGame的朋友只有GameAbout,GameAbout的朋友有三个
 * 5.开闭原则：（add而不是update）
 * 对扩展开放，对修改关闭。换句话说，当需求发生变化时，应该通过增加新的代码来扩展现有功能，而不是直接修改现有代码。
 * 抽象类和接口、模板方法、策略模式
 * 假设我们有一个计算器程序，支持加、减、乘、除四种运算。现在要增加一种运算，即求幂运算。
 * 如果我们直接修改原有的代码来添加这个功能，那么就会违反开闭原则。但是，如果我们使用策略模式来遵循开闭原则，
 * 就可以将不同的运算封装成策略类，并将计算器类和具体的运算策略解耦。这样，当我们需要增加新的运算时，只需要实现新的策略类，
 * 而不需要修改已有的代码。
 *
 * 6.里氏替换原则：
 * 子类对象可以替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变。这意味着子类在扩展父类功能时，
 * 不能改变父类的原有功能‌
 * 举例：
 * 假设有一个鸟类（Bird）和一个几维鸟类（Kiwi），几维鸟是鸟类的一种，但它不能飞行。如果设计一个鸟类的基类，
 * 其中有一个飞行的方法，而几维鸟类继承了这个基类并重写了飞行方法（但实际上是不飞行的），这就违反了里氏替换原则。
 * 因为当用几维鸟对象替换鸟类对象时，程序的行为会发生变化（例如，期望鸟类对象能飞行，但几维鸟对象不能飞行）。
 * 正确的做法是，可以定义一个更一般的父类（如动物类），鸟类和几维鸟类都继承这个父类，但鸟类实现飞行方法，
 * 而几维鸟类不实现或实现一个空方法。
 *
 * 思考：
 * 单一职责和迪米特法则的区别：
 * 单一职责关注的是类的职责划分
 * 迪米特法则关注的是对象之间的交互和依赖关系
 * 场景一：订单处理系统
 * 单一职责原则应用：
 * 我们可以将订单的创建、支付、发货和完成等逻辑分离到不同的类中，每个类只负责一个具体的职责。例如，创建订单的逻辑放在OrderCreator类中，支付订单的逻辑放在OrderPayer类中，以此类推。
 * 这样，每个类都有一个明确的职责，并且只关注于自己负责的功能，降低了类的复杂度，提高了代码的可读性和可维护性。
 * 迪米特法则应用：
 * 在订单处理系统中，如果有一个OrderProcessor类需要处理订单的各种状态变化（如创建、支付、发货等），但又不希望直接依赖于具体的订单处理类（如OrderCreator、OrderPayer
 * 等），那么可以通过引入一个中间层（如OrderService）来降低OrderProcessor与具体订单处理类之间的耦合度。
 * OrderService类负责接收OrderProcessor的请求，并根据请求调用相应的订单处理类的方法。这样，OrderProcessor类就只需要与OrderService类进行交互，而不需要了解具体的订单处理类的实现细节。
 * 这样做的好处是降低了OrderProcessor类与其他类之间的依赖关系，提高了系统的可维护性和可扩展性。
 *
 */
public class Introduce {
    public static void main(String[] args) {
        /*
         * 两厂一单原构建，
         * 外代组享装适桥。
         * 策略模板两状态，
         * 观迭任命终结者。
         */
    }
}
